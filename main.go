package main

import (
	"context"
	"encoding/base64"
	"fmt"
	"log"
	"net/http"
	"os"
	"strings"
	"time"

	"github.com/BurntSushi/toml"
	"github.com/gin-gonic/gin"
	swaggerFiles "github.com/swaggo/files"     // swagger embed files	"go.mongodb.org/mongo-driver/bson"
	ginSwagger "github.com/swaggo/gin-swagger" // gin-swagger middleware

	// "github.com/swaggo/swag/example/basic/docs"
	"go.mongodb.org/mongo-driver/bson"
	"go.mongodb.org/mongo-driver/mongo"
	"go.mongodb.org/mongo-driver/mongo/options"

	_ "example.com/pokemon-handbook/docs" // import docs generated by Swag CLI
)

type pokemon struct {
	ID          string `json:"id"`
	Name        string `json:"name"`
	IsLegendary bool   `json:"is_legendary"`
	Color       string `json:"color"`
}

type Config struct {
	DatabaseURL    string
	DatabaseName   string
	CollectionName string
	URL            string
	UserName       string
	Password       string
	UserName1      string
	Password1      string
	UserName2      string
	Password2      string
	UserName3      string
	Password3      string
}

var config Config

func ReadConfig() Config {
	var configFile = "properties.ini"
	_, err := os.Stat(configFile)
	if err != nil {
		log.Fatal("Config file is missing: ", configFile)
	}

	if _, err := toml.DecodeFile(configFile, &config); err != nil {
		log.Fatal(err)
	}
	return config
}

func connectToMongoDB() (*mongo.Collection, context.CancelFunc, error) {

	ctx, cancel := context.WithTimeout(context.Background(), 20*time.Second)
	client, err := mongo.Connect(ctx, options.Client().ApplyURI(config.DatabaseURL))
	var collection *mongo.Collection
	if err == nil {
		fmt.Printf("Client value %v\n", client)

		collection = client.Database(config.DatabaseName).Collection(config.CollectionName)
		fmt.Printf("Collection value %v\n", collection)
	}

	return collection, cancel, err
}

func init() {
	fmt.Println("This is init")

	config = ReadConfig()
}

// @title           Swagger Example API
// @version         1.0
// @description     This is a sample server celler server.
// @termsOfService  http://swagger.io/terms/

// @contact.name   API Support
// @contact.url    http://www.swagger.io/support
// @contact.email  support@swagger.io

// @license.name  Apache 2.0
// @license.url   http://www.apache.org/licenses/LICENSE-2.0.html

// @host      localhost:8080
// @BasePath  /api/v1

// @securityDefinitions.basic  BasicAuth
func main() {
	fmt.Println("This is main")

	router := gin.Default()

	authorized := router.Group("/", gin.BasicAuth(gin.Accounts{
		config.UserName:  config.Password,
		config.UserName1: config.Password1,
		config.UserName2: config.Password2,
		config.UserName3: config.Password3,
	}))

	authorized.POST("/pokemons", postPokemon)
	router.GET("/pokemons", getPokemons)
	router.GET("/pokemons/:id", getPokemonByID)
	authorized.PUT("/pokemons/:id", updatePokemonByID)
	authorized.DELETE("/pokemons/:id", deletePokemonByID)
	router.DELETE("/pokemons", adminBasicAuth, deleteAllPokemons)

	// use ginSwagger middleware to serve the API docs
	router.GET("/swagger/*any", ginSwagger.WrapHandler(swaggerFiles.Handler))

	router.Run(config.URL)
}

func adminBasicAuth(c *gin.Context) {
	auth := strings.SplitN(c.Request.Header.Get("Authorization"), " ", 2)

	if len(auth) != 2 || auth[0] != "Basic" {
		respondWithError(401, "Unauthorized", c)
		return
	}

	payload, _ := base64.StdEncoding.DecodeString(auth[1])
	pair := strings.SplitN(string(payload), ":", 2)

	if len(pair) != 2 || !authenticateUser(pair[0], pair[1]) {
		respondWithError(401, "You have not rights", c)
		return
	}

	c.Next()
}

func authenticateUser(user, password string) bool {
	if user == config.UserName && password == config.Password {
		return true
	}
	return false
}

func respondWithError(code int, message string, c *gin.Context) {
	resp := map[string]string{"error": message}

	c.JSON(code, resp)
	c.Abort()
}

// Post Pokemon godoc
// @title        Post Pokemon
// @summary      Post pokemon to the MongoDB
// @description  Post a pokemon to the MongoDB. If the database doesn't exist, create and insert a new value. Pass values in json format.
// @produce      json
// @success      201 {object} pokemon
// @failure      400      {string}  string        "object can't be parsed into JSON"
// @router       /pokemons [post]
func postPokemon(c *gin.Context) {
	var newPokemon pokemon

	if err := c.BindJSON(&newPokemon); err != nil {
		c.IndentedJSON(http.StatusBadRequest, gin.H{"message": "object can't be parsed into JSON"})
		return
	}

	collection, cancel, err := connectToMongoDB()
	defer cancel()
	if err != nil {
		fmt.Println(err)
		return
	}

	res, err := collection.InsertOne(context.Background(), newPokemon)
	if err != nil {
		fmt.Println(err)
		return
	}
	id := res.InsertedID
	fmt.Printf("id value %v\n", id)

	// pokemons = append(pokemons, newPokemon)
	c.IndentedJSON(http.StatusCreated, newPokemon)
}

// GetPokemons godoc
// @title        Get Pokemons
// @summary      Retrieves all pokemons from the MongoDB
// @description  Get all pokemons from the MongoDB. Pass values in json format.
// @produce      json
// @success      200 {array} pokemon
// @failure      400      {string}  string        "object can't be parsed into JSON"
// @failure      404      {string}  string        "Error: Not Found"
// @router       /pokemons [get]
func getPokemons(c *gin.Context) {
	var pokemons = []pokemon{}

	collection, cancel, err := connectToMongoDB()
	defer cancel()
	if err != nil {
		fmt.Println(err)
		return
	}

	cur, err := collection.Find(context.Background(), bson.D{})
	if err != nil {
		log.Fatal(err)
	}
	defer cur.Close(context.Background())
	for cur.Next(context.Background()) {
		// To decode into a struct, use cursor.Decode()
		result := pokemon{}
		err := cur.Decode(&result)
		if err != nil {
			log.Fatal(err)
		}
		fmt.Printf("Pokemon entry: %v\n", result)
		pokemons = append(pokemons, result)

		// To get the raw bson bytes use cursor.Current
		raw := cur.Current
		fmt.Printf("Raw result entry: %v\n", raw)
	}
	if err := cur.Err(); err != nil {
		fmt.Println(err)
		return
	}
	c.IndentedJSON(http.StatusOK, pokemons)
}

// GetPokemonByID godoc
// @title        Get Pokemon By ID
// @summary      Retrieve pokemon from the MongoDB based on given ID
// @description  Get a pokemon from the MongoDB by ID. Pass values in json format. If there aren't any pokemon with the ID gives a message "pokemon not found".
// @produce      json
// @success      200 {object} pokemon
// @failure      404      {string}  string        "pokemon not found"
// @router       /pokemons/{id} [get]
func getPokemonByID(c *gin.Context) {
	id := c.Param("id")

	collection, cancel, err := connectToMongoDB()
	defer cancel()
	if err != nil {
		fmt.Println(err)
		return
	}

	result := pokemon{}
	err = collection.FindOne(context.Background(), bson.D{{Key: "id", Value: id}}).Decode(&result)
	if err != nil {
		c.IndentedJSON(http.StatusNotFound, gin.H{"message": "pokemon not found"})
		// log.Fatal(err)
		return
	}
	c.IndentedJSON(http.StatusOK, result)
}

// UpdatePokemonByID godoc
// @title        Update Pokemon By ID
// @summary      Update pokemon's data in the MongoDB based on given ID
// @description  Update an existing pokemon in the MongoDB by ID. Pass values in json format. If there isn't pokemon with the ID creates a new pokemon.
// @produce      json
// @success      200 {object} pokemon
// @failure      201      {string}  string        ""
// @router       /pokemons/{id} [put]
func updatePokemonByID(c *gin.Context) {
	var newPokemon pokemon

	if err := c.BindJSON(&newPokemon); err != nil {
		c.IndentedJSON(http.StatusBadRequest, gin.H{"message": "object can't be parsed into JSON"})
		return
	}

	collection, cancel, err := connectToMongoDB()
	defer cancel()
	if err != nil {
		fmt.Println(err)
		return
	}

	opts := options.FindOneAndUpdate().SetUpsert(true)
	filter := bson.D{{Key: "id", Value: newPokemon.ID}}
	update := bson.D{{Key: "$set", Value: newPokemon}}
	var updatedPokemon bson.M
	err = collection.FindOneAndUpdate(
		context.Background(),
		filter,
		update,
		opts,
	).Decode(&updatedPokemon)
	if err != nil {
		if err == mongo.ErrNoDocuments {
			// pokemons = append(pokemons, newPokemon)
			fmt.Printf("id value %v\n", newPokemon.ID)
			c.IndentedJSON(http.StatusCreated, newPokemon)
			return
		}
		log.Fatal(err)
	}
	c.IndentedJSON(http.StatusOK, gin.H{"message": "pokemon was updated"})
}

// DeletePokemonByID godoc
// @title        Delete Pokemon By ID
// @summary      Delete pokemon in the MongoDB based on given ID
// @description  Delete an existing pokemon in the MongoDB by ID and gives a message. Pass values in json format. If there isn't pokemon with the ID gives a message.
// @produce      json
// @success      200 {object} pokemon "pokemon was deleted"
// @failure      201      {string}  string        "pokemon not found"
// @router       /pokemons/{id} [delete]
func deletePokemonByID(c *gin.Context) {
	id := c.Param("id")

	collection, cancel, err := connectToMongoDB()
	defer cancel()
	if err != nil {
		fmt.Println(err)
		return
	}

	res, err := collection.DeleteOne(context.Background(), bson.D{{Key: "id", Value: id}})
	if err != nil {
		log.Fatal(err)
		return
	}
	// pokemons = append(pokemons[:s], pokemons[s+1:]...)
	if res.DeletedCount == 0 {
		c.IndentedJSON(http.StatusNotFound, gin.H{"message": "pokemon not found"})
	} else {
		c.IndentedJSON(http.StatusOK, gin.H{"message": "pokemon was deleted"})
	}
}

// DeleteAllPokemons godoc
// @title        Delete All Pokemons
// @summary      Delete all pokemons in the MongoDB
// @description  Delete all existing pokemons in the MongoDB and gives a message "all pokemons are deleted". Pass values in json format. If there aren't pokemons in the database gives a message "pokemons not found".
// @produce      json
// @success      200 {object} pokemon "all pokemons was deleted"
// @failure      404      {string}  string        "pokemons not found"
// @router       /pokemons [delete]
func deleteAllPokemons(c *gin.Context) {
	collection, cancel, err := connectToMongoDB()
	defer cancel()
	if err != nil {
		fmt.Println(err)
		return
	}

	res, err := collection.DeleteMany(context.Background(), bson.D{})
	if err != nil {
		log.Fatal(err)
		return
	}
	// pokemons = make(map[int]pokemon)
	if res.DeletedCount == 0 {
		c.IndentedJSON(http.StatusNotFound, gin.H{"message": "pokemons not found"})
	} else {
		c.IndentedJSON(http.StatusOK, gin.H{"message": "all pokemons was deleted"})
	}
}
